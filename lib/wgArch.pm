#!/usr/local/bin/perl

package wgArch;

# A wgArch object represents an archive
# May contain several wgRoot objects representing linktrees & directories
#
# Create as follows:
#
#      mArch = new wgArch($archid, $archdir);
#
# where at least 1 of archid, archdir must be known (the other may be null)
#
# Functions:
#
#	new
#	LoadRoots
# 	SaveRoots
#	Validate
#	Create
#	Build
#	


my $REVISION = '$Id $';

my $DEFAULTID = 0;

BEGIN {
	use wgHeader qw( :wgarch :makenh :general );  # imports $CONFIGFILE, $ArchiveList
	use wgErrors;
}

use wgRoot;
use wgConf;
use wgSiteConf;
use AllowDeny;
use CommandWeb;
use LangUtils;
use wgTextMsgs;

##################################################################
# Public data members:


my $ArchVars= 'ID Dir Title CatCode SearchURL Description Lang AddBoxes PreFilter';
$ArchVars .= ' UseSF SFtrackID SFpID SFnum SFkeywords '; # plus @Roots

@members = split(/\s+/, $ArchVars);

# files that need variable substitution
my $ArchFiles = "wgindex.html wgbox.html wgall.html wgsimple.html wgverysimple.html .glimpse_filters $CRONFILE $WRCRONFILE wusage.conf wgoutput.cfg newquery.html";
@archfiles = split(/\s+/,$ArchFiles);

##################################################################

my $debug = 0;

($debug) && (print "Content-type: text/html\n\n");

1;


# May be called with all vars, or just with $ID or $Dir
sub new {
        my $class = shift;
        my $self = {};
        bless $self, $class;

	my ($varname, $val, $j);

	$self->{AddBoxes} = 'N';  # set default in case we read an old list without any value

	$self->{PreFilter} = '';	# which exts from .glimpse_filters to preapply; can be space seperated list "htm pdf html PDF" or just "all"

	$self->{UseSF} = 'N';
	$self->{SFtrackID} = '';
	$self->{SFpID} = '';
	$self->{SFnum} = 2;
	$self->{SFkeywords} = '';

	$j = 0;
	foreach $val (@_) {
		$varname = $members[$j];
		$self->{$varname} = $val;
		$j++;
	}

	$self->{Roots} = [];

	$self->{LoadedRoots} = 0;

	$self->{LastID} = 0;

	$self->{StatusMsg} = '';


	return $self;
}

sub SetCheckboxesOff { 	# default checkbox values to 'N' for accepting form update
	$self = shift;
	$self->{UseSF} = 'N';
	$self->{AddBoxes} = 'N';
}

sub SetSearchURL {
	my $self = shift;

	&wgSiteConf::LoadSites;
	my $dom = $wgSiteConf::LocalServerName || 'arch-unknown';
	$self->{SearchURL} = "http://$dom/$CGIBIN/webglimpse.cgi?ID=".$self->{ID};
}

sub Register {
	my $self = shift;

	if ($REGISTER_ARCHIVES && ($REGISTER_AT ne '') && ( -e $SENDMAIL)) {

		open(MAIL, "| $SENDMAIL -t");

		my $title = $self->{Title};

		print MAIL <<EOM;
To: $REGISTER_AT
From: $ADMIN_EMAIL
Subject: New WG Archive: $title

$title

EOM

		print MAIL $self->{Description},"\n\n";


		print MAIL $self->{SearchURL};

		print MAIL "\n----------------------------\n";
		print MAIL "The above information was automatically generated by Webglimpse version $VERSION\n";
		print MAIL "\n.\n\n";

		close MAIL;
		return 1;
	} else {
		return 0;
	}
}

sub RegisterUpdate {
	my $self = shift;
# TODO - actually belongs in wgreindex script
}


sub Get {
        my $self = shift;
        my $varname = shift;

        my $ret = '';

        if ($ArchVars =~ /(^|\s)$varname(\s|$)/) {
                $ret = $self->{$varname};
        } elsif ($varname eq 'Status') {
		$ret = $self->GetStatus;
	} elsif ($varname eq 'StatusMsg') {
		# TODO check that GetStatus has been called
		$self->GetStatus;
		$ret = $self->{StatusMsg};
	} elsif ($varname eq 'WusageLink') {
		my $wusage_url;
		my $wusage_dir = $WUSAGE_DIR.'/'.$self->{ID};
		if ($WUSAGE_DIR && ( -d $wusage_dir)) {
			&wgSiteConf::LoadSites;
			$wusage_url =  &wgSiteConf::LocalFile2URL($wusage_dir);
			if ($wusage_url) {
				$ret = "<A HREF='$wusage_url'>Usage Reports</A>";
			}
		}
	}

        return $ret;
}     




##################################################################################
# GetStatus, LastBuilt
#
# An archive may have the following Status
#
# 	OK - indexes built, searchable
#	Indexing - indexing in progress
#	NeedsIndex - has at least 1 valid root, not yet indexed
#	NeedsDomain - one or more domains not configured
#	NeedsRoots - no valid roots in archive
#	InValid - unexpected missing piece 
#
# LastBuilt = date when archive was last reindexed

#TODO: build up more detailed status message
sub GetStatus {
	my $self = shift;

	my ($hasroot, $mroot, $mdomain, $hoststatus, $ret);
	$self->{StatusMsg} = '';

	# Sanity check -does archive dir exist?
	(-d $self->{Dir}) 
		|| ($self->{StatusMsg} = "Archive Directory ".$self->{Dir}." does not exist.") 
		&& return($INVALID);

	# Check if we have roots, and if each root has starting domain configured
	$hasroot = 0;


	# Load roots if not already loaded
        $self->LoadRoots;

	foreach $mroot (@{$self->{Roots}}) {
		if ($mroot->Validate) {
			$hasroot = 1;
		} else {
			$self->{StatusMsg} .= "Invalid root, error was $lastError\n";
		}
		
		# Dir-type roots must have domain configured
		# Site and Trees will assume domain is remote if not configured as local
		if ($mroot->{Type} eq 'DIR'){
			$mdomain = $mroot->Get('Domain');
			my $murl = $mroot->Get('StartURL') || $mdomain;
			$hoststatus = &wgSiteConf::CheckSite($murl);
			if ($hoststatus != $OK) { 
				$self->{StatusMsg} .= $wgTextMsgs::CONFIGURE_DOMAIN;
				$self->{StatusMsg} =~ s/\|DOMAIN\|/$mdomain/g;
				$self->{StatusMsg} =~ s/\|WGARCMIN\|/\/$CGIBIN\/wgarcmin.cgi/g;
				return ($NEEDSDOMAIN);
			}
		}	

	}
	$hasroot || ($self->{StatusMsg} .= "Nothing to index") && return($NEEDSROOTS);

	# Check if indexing is currently in progress
	(-e "$self->{Dir}/indexing-in-progress") 
		&& ($self->{StatusMsg} .= "Indexing in progress")
		&& return($INDEXING);


	# Check if index is built
	(-e "$self->{Dir}/.glimpse_index") 
		|| ($self->{StatusMsg} .= "Ready to build index") 
		&& return($NEEDSINDEX); 	

	# Everything is fine, put last built date in status message
	$self->LastBuilt;

	# Also add # files indexed
	$self->NumFiles;

	return $OK;
}


# Puts lastbuilt date string in StatusMsg, returns ctime
sub LastBuilt {

	my $self = shift;

	# Check date on index file
	my $indx = $self->{Dir}."/.glimpse_index";

	if (! -e $indx) {
		$self->{StatusMsg} = "Error, glimpse index $indx does not exist";
		return -1;
	}

	@_ = stat($indx);

	my $mtime = $_[9];

	@_ = localtime($_[9]);

	my $nicedate = sprintf("%02d\/%02d\/%d", $_[4]+1, $_[3], $_[5]+1900);
	my $nicetime = sprintf("%02d\:%02d\:%02d", $_[2], $_[1], $_[0]);

	$self->{StatusMsg} .= "Last built $nicedate at $nicetime";

	return($mtime); 
}

sub NumFiles {
	my $self = shift;

	my $files = $self->{Dir}."/.glimpse_filenames";

	my $numfiles = 0;

	open(F,$files) || close(F) && return(-1);
	$numfiles = <F>;	# stored as the first line
	close F;

	chomp $numfiles;

	$self->{StatusMsg} .= " $numfiles files indexed.";

	if ($numfiles <= 0) {
		$self->{StatusMsg} .= "<br><i>Troubleshooting suggestion:</i> Check the files .wg_err and .wg_log in the directory ".$self->{Dir}.".  If you have shell access, you can also try to run the <b>wgreindex</b> command manually from that directory to see why no files were indexed.";
	}

	return $numfiles;
}



sub Validate {
	my $self = shift;
	# Internal consistency check of settings
	# Return ok or set error

	$self->LoadRoots || return(0);
	
	($#{$self->{Roots}} >= 0) || return $NEEDSROOTS;

	(-d $self->{Dir}) || return $NEEDSDIR;

	return (1);
}


sub Destroy {
	my $self = shift;
	
	my($ret,$dir);

	# First remove the listing from the ARCHIVE_LIST file
	$ret = &wgConf::DelEntry($self->{ID});	 # lastError should already be set if an error occurred

	$dir = $self->{Dir};

	#TODO: remove search boxes from web files in archive

	# Then try to remove the directory & contents
	if (! -d $dir) {
		$lastError .= " $dir is not a directory.";
		return 0;
	}

	# Is this a directory we manage?  Don't delete other dirs, they might have other contents also.
	if ($dir !~ /^$WGARCHIVE_DIR/) {
		$lastError .= " Archive directory $dir is not under $WGARCHIVE_DIR.  Please delete the archive files manually, they have not been deleted.";
		return 0;
	}

	# Sanity check - make sure we have absolute path (who knows what WGARCHIVE_DIR might be set to!)
	if ($dir !~ /^\/.+/) {
		$lastError .= " Archive directory $dir does not appear to be an absolute path.  Please delete the archive files manually, they have not been deleted.";
		return 0;
	}

	# Ok, lets do it
	`rm -rf $dir`;

	if (-e $dir) {
		$lastError .= " Unable to delete archive directory $dir ";
		$ret = 0;
	}

	return $ret;
}


sub Create {	
	my $self = shift;
	my $tmpdir = '';

	# Default to archivedir/ID if Dir not defined or empty string
	if ( ! $self->{Dir} ) {
		defined($self->{ID}) || return(0);
		$self->{Dir} = $WGARCHIVE_DIR.'/'.$self->{ID};
	}

	# Generate an archiveid if not defined
	defined($self->{ID}) || ($self->{ID} = $DEFAULTID);

	# default new archives to using Prefilter option
	$self->{PreFilter} = 'all';

	# Try to create directory if it doesn't exist
	if ( ! -d $self->{Dir} ) {

		mkdir($self->{Dir},0755) || ($lastError = "mkdir failed: $!") && return(0);
	}

	# Just for fun, set language environment vars (shouldn't make any difference)
	if (defined($self->{Lang}) && ($self->{Lang} ne '') && ($self->{Lang} ne 'english')) {
	        $ENV{'LANG'} = &LangUtils::GetCode($lang);
        	$ENV{'LC_ALL'} =  &LangUtils::GetCode($lang);
	}
	

	# Create wgreindex & other files
	$self->MakeArchFiles || return(0);

	# Add to .archives list and .wgcron
	(&wgConf::AddEntry($self) == $OK) || return(0);

	# Make wusage subdir if we are using it
	if (($WUSAGE ne '#') && $WUSAGE_DIR) {
		$tmpdir = $WUSAGE_DIR.'/'.$self->{ID};
		if (! -d $tmpdir) {
			mkdir($tmpdir, 0755);   # Failure here is not critical
		}
	}

	# Set URL to search from (later may be static wgindex.html)
	$self->SetSearchURL;

	# Register with central repository if user has allowed it
	if ($REGISTER_ARCHIVES eq 'Y') {
		$self->Register;
	}

	# Return ok or error
	return(1);
}




# Create wgreindex script, any other configurable archive files
# Called as an object member so we can access specific config options
sub MakeArchFiles {
	my $self = shift;

	my ($wgtemplate, $cronfile, $varname, %vars);

	my $indexdir = $self->{Dir};

	# Copy over dist files
	&CopyDistFiles($indexdir);

	no strict 'refs';
	
	# First one is wgreindex

	foreach $varname ('WGHOME','WEBGLIMPSE_LIB','CAT','PERL',
			  'GLIMPSE_LOC','GLIMPSEIDX_LOC','CONVERT_LOC','CGIBIN','HTML2TXTPROG', 'SENDMAIL','ADMIN_EMAIL',
			  'LOCKFILE','GHROBOT','ADDSEARCH','CRONFILE','TOINDEX','MADENH', 'WUSAGE_DIR', 'LOGFILE', 'WUSAGE') {
		$vars{$varname} = $$varname;
	}

	$vars{'ID'} = $self->{ID};
	$vars{'INDEXDIR'} = $indexdir;
	$vars{'DIR'} = $indexdir;
	$vars{'TITLE'} = $self->{Title};
	$vars{'CATCODE'} = $self->{CatCode};
	$vars{'ADDBOXES'} = $self->{AddBoxes};
	$vars{'PREFILTER'} = $self->{PreFilter};
	$vars{'LANG'} = $self->{Lang};
	$vars{'USESF'} = $self->{UseSF};
	$vars{'SFTRACKID'} = $self->{SFtrackID};
	$vars{'SFPID'} = $self->{SFpID};
	$vars{'SFNUM'} = $self->{SFnum};
	$vars{'SFKEYWORDS'} = $self->{SFkeywords};
	$vars{'METACHARSET'} = &LangUtils::makeMetaTag($self->{Lang});
	$vars{'LC'} = &LangUtils::GetCode($self->{Lang});
	$vars{'PROPERLANG'} = &LangUtils::GetProperName($self->{Lang});
#	TODO: add webmin option for different HTML2TXTPROG


# TODO: make dir list for wgall.html if dir type archive
# if archive has no dir type roots, no purpose for wgall?
	$vars{DIRECTORYOPTIONS} = $self->MakeDirOptions;

	if ($self->{UseMaxMem}) {
		$vars{'CONVERT_OPTIONS'} = "-U -P .nh. -M -F -ni";
	} else {
		$vars{'CONVERT_OPTIONS'} = "-U -P .nh. -F -ni";	
	}
	
	$vars{'SHELL'} = `which sh`    || '/bin/sh';
	$vars{'RM'}    = `which rm`    || '/bin/rm';
        $vars{'MV'}    = `which mv`    || '/bin/mv';  # more commands needed for $WRCRONFILE=wrwgreindex [TT]
        $vars{'CP'}    = `which cp`    || '/bin/cp';
        $vars{'MKDIR'} = `which mkdir` || '/bin/mkdir';
        $vars{'SED'}   = `which sed`   || '/bin/sed';

	chomp $vars{'SHELL'};
	chomp $vars{'RM'};
	chomp $vars{'MV'}; # as above [TT]
	chomp $vars{'CP'};
	chomp $vars{'MKDIR'};
	chomp $vars{'SED'};


	foreach $tfile (@archfiles) {

		# If LANG is set, look in subdirectory first

		if (($self->{Lang}) && ($self->{Lang} ne 'english') && ( -e $WGTEMPLATES.'/'.$self->{Lang}.'/'.$tfile)) {
			$wgtemplate = $WGTEMPLATES.'/'.$self->{Lang}.'/'.$tfile;
		} else {
			$wgtemplate = $WGTEMPLATES.'/'.$tfile;
		}

		$outfile = $indexdir.'/'.$tfile;

		&CommandWeb::OutputToFile($wgtemplate, $outfile, \%vars) 
			|| (($lastError = $CommandWeb::lastError) && return(0));
	}
	
	# CRONFILE is special, needs to be executable
	chmod (0755, "$indexdir/$CRONFILE") 
		|| (($lastError = "chmod $cronfile failed: $!") && return(0));
	chmod (0755, "$indexdir/$WRCRONFILE") # also process the special reindexing file for scientific prints repository [TT]
		|| (($lastError = "chmod wr.$cronfile failed: $!") && return(0));

	if (! -e "$indexdir/$MADENH") {
		# touch the .wg_madenh file -- otherwise, the first call to addsearch -r
		# in the cron file will fail
		open(FILE, ">$indexdir/$MADENH");
		close(FILE);
		chmod(0644, "$indexdir/$MADENH") 
			|| (($lastError = "chmod $indexdir/$MADENH failed: $!") && return(0));
	}

	# Touch the archive.cfg file, it is now empty until we add some Roots to the archive
	if (! -e "$indexdir/$CONFIGFILE") {
		open(FILE, ">$indexdir/$CONFIGFILE");
		close(FILE);
		chmod(0644, "$indexdir/$CONFIGFILE")
			|| (($lastError = "chmod $indexdir/$CONFIGFILE failed: $!") && return(0));
	}
	return 1;
}



# General utility function, not used as object member
sub CopyDistFiles {
	my $indexdir = shift;

	my $file;
	opendir(DIR, $WEBGLIMPSE_DIST) || ($lastError = "CopyDistFiles: opendir $WEBGLIMPSE_DIST failed: $!") && return (0);

	while ($file = readdir(DIR)) {
			# WEIRD BUG if have (\.)|(\.\.) - matches anything with a . at all
			next if ($file =~ /^(CVS)|(README)|(\.\.)|(\.)$/);

			$debug && (print "Copying over dist file $file\n");
			system("cp -f $WEBGLIMPSE_DIST/$file $indexdir/.$file");
			chmod(0644, "$indexdir/.$file") || ($lastError = "CopyDistFiles: chmod $indexdir/.$file failed: $!") && return(0);
	}
	closedir(DIR);
	return(1);
}



sub Build {
	my $self = shift;
	my $outputref = shift;
	my @output = ();
	my $line;
	my $eol = "<br>\\n\" \+\n\"";

	# Verify that wgreindex exists
	my $wgreindex = $self->{Dir}.'/'.$CRONFILE;
	(-e $wgreindex) || (($lastError = "can't find cronfile $wgreindex") && return(0));	
	
	# Run wgreindex

	$| = 1;

	# We need to run in the background, too often this times out in the middle of the script
	if (system("$wgreindex -q  1>/dev/null 2>/dev/null &") == 0) {
		my $maxsleep = 5;
		my $wait = 0;
		while (($wait < $maxsleep) && (! -e "$self->{Dir}/indexing-in-progress")) {
			sleep 1;
		}

		# If registering, update the last-indexed date
		if ($REGISTER_ARCHIVES eq 'Y') {
			$self->RegisterUpdate;
		}

		return 1; 
	} else {
		$lastError = $!;
		return 0;
	}	

#	@output = `$wgreindex -q &`;		# Do not use -q, we want to see results

#	$$outputref = "<HTML><BODY><H3>Build Results</H3>$eol";

#	foreach $line (@output) {
#		chomp $line;
#		$line =~ s/\"/\\\"/g;
#		$$outputref .= $line;
#		$$outputref .= $eol;
#	}
#	substr($$outputref, -11) = "";
#
#	$$outputref .= "</BODY></HTML>";
#
#	# Return ok or error
#	return(1);
}



sub AddRoot {
	my $self = shift;
	my $mRoot = shift;

	# TODO: Check if already exists StartURL in @Roots list

	push @{$self->{Roots}}, $mRoot;
}


sub DelRoot {
	my $self = shift;
	my $url = shift;

	if ($#{$self->{Roots}} < 0) {
		$self->LoadRoots || return(0);
	}

	my ($j,$mroot, $deleted);
	$deleted = 0;
	for ($j=0; $j<=$#{$self->{Roots}}; $j++) {
		$mroot = ${$self->{Roots}}[$j];
		if ($mroot->{StartURL} eq $url) {
			${$self->{Roots}}[$j] = 0;
			$deleted = 1;	
			last;
		}
	}

	if (!$deleted) {
		$lastError = "Not able to find root matching $url";
		return 0;
	}

	$self->SaveRoots || return 0;

	$self->LoadRoots(1);

	return 1;
}


sub GetRoots {
	my $self = shift;

	if ($self->{LastID} <= 0) {
		$self->LoadRoots;
	}

	# Return array of wgRoot objects as specified in archive.cfg
	return $self->{Roots};
}


sub GetRoot {
	my $self = shift;

	# Return reference to the root with $url = StartURL
	# if passed null or blank $url, we return the first root
	my $url = shift;
	my $root;	

	foreach $root (@{$self->{Roots}}) {
		if (($root->{StartURL} eq $url) || (!$url)) {
			return $root;
		}
	}
	return 0;
}



# Format of archive.cfg
# 
# same as for 1.X versions, except extra info available after each url
#
# 1 entry per wgRoot object:
#
# <ArchRoot starturl>
# (all settings optional except Type)
# StartDir  dir
# Type type
# Hops hops
# FollowToRemote
# FollowSameSite
# FollowAll
# MaxLocal pages
# MaxRemote pages
# Local_Flag
# Keep_Flag
# MakeNH_Flag
# CheckHtaccess
# IndexFreq freq
# LimitPrefix prefix
# UseRegExp
# IndexTrunk
# </ArchRoot>
#
# This probably should live in wgHeader.pm or wgRoot.pm

sub LoadRoots {
	my $self = shift;
	my $force = shift || 0;

	my ($name, $val, $wgroot, $nicename, $StartURL);

	# If we have already loaded them, just return
	$self->{LoadedRoots} && (! $force) && return(1);

	# Verify that archive.cfg exists
	my $cfgfile = $self->{Dir}.'/'.$CONFIGFILE;
	(-e $cfgfile) || ($lastError = "$cfgfile doesn't exist") && return(0);

	# Read config variables
	open(F, $cfgfile) || ($lastError = "Can't open $cfgfile") && return(0);

	# Empty Roots array
	$self->{Roots} = [];

	while(<F>) {

		# skip comments
		/^\#/ && next;

		# trim leading & trailing whitespace
		s/^\s+//;
		s/\s+$//;
		chomp;
		next unless length;	# skip blank lines

		# Are we starting a new root or ending one?
		if (/<\/ArchRoot\>/i) {
			undef $wgroot;
			next;
		}

		if (/<ArchRoot\s+([^\s\>]+)>/i) {
			$StartURL = $1;
			$wgroot = new wgRoot($StartURL);

			push @{$self->{Roots}}, $wgroot;
			next;
		}

		# get the config variable
		undef $val;
		($name, $val) = split(/\s+/,$_,2);  # support spaces in values

		if (defined($wgroot) && ($nicename = &wgRoot::isMember($name))) {

			if (!defined($val) ) {
				if ( &wgRoot::isFlag($name)){
				 	$val = 1;	# Flags may be set without a value
				} else {
					$val = '';
				}
			} 
			$wgroot->{$nicename} = $val;		# Set member variable of root
			
		}
	}
	close F;

	$self->{LoadedRoots} = 1;

	# Return ok or error
	return(1);
}



sub SaveRoots {
	my $self = shift;

	# Verify that we can write to archive.cfg
	my $cfgfile = $self->{Dir}.'/'.$CONFIGFILE;
	(-e $cfgfile) || ($lastError = "$cfgfile doesn't exist") && return(0);
	open(F, ">$cfgfile") || ($lastError = "can't write to $cfgfile") && return(0);

	my($wgroot, $varname);
	# Write roots variables
	foreach $wgroot (@{$self->{Roots}}) {

		# Skip any nulled out roots; may have been deleted
		$wgroot || next;

		print F "<ArchRoot ",$wgroot->{'StartURL'},">\n";
		foreach $varname (@wgRoot::members) {
			if (defined($wgroot->{$varname})) {
				print F "\t",$varname,' ',$wgroot->{$varname},"\n";
			}
		}
		print F "</ArchRoot>\n\n";
	}		
	close F;

	# Return ok or error
	return(1);
}



sub MakeDirOptions {
	my $self = shift;

	my $optstring = '';
	my $wgroot;
	my $mAdIndex = new AllowDeny($self->{Dir}.'/'.$WGINDEX);
	my $addedremoteoption = 0;

	$self->LoadRoots;

	$mAdIndex->LoadAllowDeny;

        foreach $wgroot (@{$self->{Roots}}) {

		if ($wgroot->{Type} eq 'DIR') {

			$optstring .= $wgroot->MakeDirOptions($mAdIndex);
		} elsif ($addedremoteoption == 0) {

			# Site or Tree types, add option for Remote sites (might or might not be any)
                        $optstring .=  '<OPTION VALUE="^'.$self->{Dir}.'/.remote">'."Remote files\n";
			$addedremoteoption = 1;
		}
	}

	return $optstring;
}

